{"name":"Reroute","tagline":"Flexible PHP5 HTTP router","body":"# reroute\r\nFlexible PHP5 HTTP router\r\n\r\nInstallation\r\n------------\r\n\r\n###Composer (recommended)###\r\n\r\n1. Add a requirement to \"monomelodies/reroute\" to your `composer.json`;\r\n2. Run `composer install`.\r\n\r\n###Cloning with Git###\r\n\r\n1. Clone the repository;\r\n2. Include the files you'll need, or register `/path/to/reroute/src` in a\r\n   PSR-4 autoloader.\r\n\r\n###Manual download###\r\n\r\n1. Download the repository;\r\n2. Unpack to a location of your choice;\r\n2. Include the files you'll need, or register `/path/to/reroute/src` in a\r\n   PSR-4 autoloader.\r\n\r\nDefining routes\r\n---------------\r\n\r\n###The basics###\r\n\r\nTo match a route (a URI endpoint) to a state:\r\n\r\n    <?php\r\n\r\n    use Reroute\\Router;\r\n    use Reroute\\Url\\Flat;\r\n\r\n    $router = new Router;\r\n    $router->state('home', new Flat('/'), function() {\r\n        echo 'Hello world!';\r\n    });\r\n    $state = $router->resolve($_SERVER['REQUEST_URI']);\r\n    $state->run();\r\n\r\nThe second argument $verbs to a Url constructor defaults to ['GET'], since\r\nthat is the most common use case in web applications.\r\n\r\n###Matching multiple HTTP verbs###\r\n\r\n    <?php\r\n\r\n    $router->state('home', new Flat('/', ['GET', 'POST']), function($verb) {\r\n        // ...\r\n    });\r\n\r\nUsing parameters\r\n----------------\r\n\r\nOf course, ReRoute supports parameters in URLs (it wouldn't be particularly\r\nuseful otherwise). In order to use parameters, you must tell your router how\r\nto handle them by passing one of the other URL classes.\r\n\r\nReRoute comes with a few bundled Url classes:\r\n\r\n- Reroute\\Url\\Flat, for simple URLs without parameters;\r\n- Reroute\\Url\\Regex, for full regex matching and maximum flexibility;\r\n- Reroute\\Url\\Legacy, for legacy Monolyth applications;\r\n- Reroute\\Url\\Angular, for AngularJS-style URL definitions;\r\n- Reroute\\Url\\Braces, for {braced} parameters.\r\n\r\nFor full documentation, see the associated pages; for this readme we will\r\nuse the modern Regex handler.\r\n\r\n    <?php\r\n\r\n    use Reroute\\Url\\Regex;\r\n\r\n    $router->state('user', new Regex('/(\\d+)/'), function($id) {\r\n        // ...\r\n    });\r\n\r\n###Named parameters###\r\n\r\nYou can specify parameters with a name. The exact syntax depends on your chosen\r\nURL class. For Regex URLs, it simply follows PHP regex syntax:\r\n\r\n    \"/(?'paramName':regex)/\"\r\n\r\nNote that the order in which they are passed to your callback is not important;\r\nthe Reroute\\State figures that out for itself.\r\n\r\n    <?php\r\n\r\n    $router->state(\r\n        'user',\r\n        new Regex(\"/(?'firstname':\\s+)/(?'lastname':\\s+)/\", ['GET', 'POST']),\r\n        function($verb, $lastname, $firstname) {\r\n            // ...\r\n        }\r\n    );\r\n\r\n###Nested matches###\r\n\r\nNesting matches (e.g. a URL containing both `{brace}`-style parameters and\r\n`:angular`-style parameters) is not supported natively. However, writing a\r\ncustom URL class supporting multiple patterns should be trivial based on the\r\nsource code.\r\n\r\nResolving routes\r\n----------------\r\n\r\nIn whatever serves as your \"front controller\", after state definition, attempt\r\nto resolve it:\r\n\r\n    <?php\r\n\r\n    $state = $router->resolve($_SERVER['REQUEST_URI']);\r\n    $state->run();\r\n\r\nGenerating URLs\r\n---------------\r\n\r\nIn your views or templates, you should refrain from hardcoding URLs to states\r\nmanaged by reroute, since changing a URL would involve changing ALL your views.\r\n\r\nInstead, make sure the template has access to the $router you defined earlier.\r\nGet a state by name and then generate a URL:\r\n\r\n    <a href=\"<?=$router->get('home')->url()->generate()?>\">Back to home page</a>\r\n    <a href=\"<?=$router->get('user')->url()->generate(['id' => 42])?>\">Go to user 42</a>\r\n\r\nRedirecting\r\n-----------\r\n\r\nThe same goes for redirects. Use either `Url::redirect` or `Url::move`:\r\n\r\n    <?php\r\n\r\n    // Redirect to home needed...\r\n    $router->get('home')->url()->redirect();\r\n\r\nThe redirect method is a pretty dumb redirector; it issues a 302 header and halts\r\nyour script. For more advanced handling, you might want to throw a custom\r\nexception and handle the redirect in a catch block, as described below.\r\n\r\nThe move method is similar, only with a 301 (permanent redirect) header.\r\n\r\nBoth `redirect` and `move` accept optional arguments a state might need ($id,\r\n$name, etc.) in the same hashtable format as `Url::generate` does.\r\n\r\nBy design, only GET states can be redirected to, since one cannot redirect a\r\nPOST anyway. A common use (and in fact best practice) would be to redirect to\r\na GET state _after_ a POST was handled, to avoid double posting.\r\n\r\nHandling 404s and other errors\r\n------------------------------\r\n\r\n    <?php\r\n\r\n    use Reroute\\Url\\Nomatch;\r\n\r\n    // First, define a 404 state:\r\n    $router->state('404', new Nomatch, function() {\r\n        echo \"The URL did an oopsie!\";\r\n    });\r\n\r\nSince `Nomatch` will never match any URL, this is a safe placeholder. But you\r\ncould use anything, really, as long as it's not already in use in your\r\napplication.\r\n\r\nNext, try to resolve the currently request URI. On failure, use the 404 state\r\ninstead:\r\n\r\n    <?php\r\n\r\n    if ($state = $router->resolve($_SERVER['REQUEST_URI'])) {\r\n        $state->run();\r\n    } else {\r\n        $router->get('404')->run();\r\n    }\r\n\r\n###Catching exceptions###\r\n\r\nA best practice is to wrap your state resolution in a try/catch block, so you\r\ncan always hide exceptions from end users, throw exceptions from states etc.:\r\n\r\n    <?php\r\n    \r\n    try {\r\n        if (!($state = $router->resolve($_SERVER['REQUEST_URI']))) {\r\n            throw new HTTP404Exception;\r\n        }\r\n        $state->run();\r\n    } catch (HTTP404Exception) {\r\n        $router->get('404')->run();\r\n    } catch (SomeOtherException) {\r\n        // ...handle accordingly...\r\n        $router->get('someOtherState')->run();\r\n    } catch (Exception) {\r\n        // Something went REALLY unexpectedly wrong...\r\n        $router->get('500')->run();\r\n    }\r\n\r\nReroute does not come bundled with these exceptions, since it's a router and\r\nnot an HTTP library, and besides we don't want to force anyone to use _our_\r\ncustom exceptions when handling their states.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}